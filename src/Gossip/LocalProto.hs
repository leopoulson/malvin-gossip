module Gossip.LocalProto where

import Gossip
import Gossip.Internal

import qualified Data.IntSet as IntSet

-- | Local protocols only depend on the State, without knowledge or any syntactical language
type LocalProtocol = State -> [Call]

localLns :: LocalProtocol
localLns ( n , s ) =
  [ (x,y) | x <- agentsOf n, y <- agentsOf n, y `IntSet.member` (n `at` x) &&  y `IntSet.notMember` (s `at` x) ]

localAnycall :: LocalProtocol
localAnycall ( n, _ ) = [ (x,y) | x <- agentsOf n, y <- IntSet.toList (n `at` x), x /= y ]

localNocall :: LocalProtocol
localNocall = const []

-- all sequences generated by a local protocol, both successful and unsuccessful
localSequences :: State -> LocalProtocol -> [Sequence]
localSequences state loproto
  | null (loproto state) = [ [] ]
  | otherwise =
      [ c : rest | c <- loproto state, rest <- localSequences (call state c) loproto ]

localSuccSequences :: State -> LocalProtocol -> [Sequence]
localSuccSequences state loproto
  | null (loproto state) = [ [] | isSolved state ]
  | otherwise =
      [ [] | isSolved state ] ++ [ c : rest | c <- loproto state, rest <- localSuccSequences (call state c) loproto ]


-- Properties of local protocols --

isWeaklySucc :: LocalProtocol -> State -> Bool
isWeaklySucc loproto state = any (isSolved . calls state) (localSequences state loproto)

isStronglySucc :: LocalProtocol -> State -> Bool
isStronglySucc loproto state = all (isSolved . calls state) (localSequences state loproto)

solvableInits :: LocalProtocol -> Int -> [State]
solvableInits loproto k = filter (isWeaklySucc loproto) (allInits k)

interestingInits :: LocalProtocol -> Int -> [State]
interestingInits loproto = filter (not . isStronglySucc loproto) . solvableInits loproto
